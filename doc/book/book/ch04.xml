<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-4">
<title>Branching and Merging</title>

  <simplesect>

    <para>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</para>

    <para>Either way, maintaining branches is a fundamental part of
      version control.  If you're going to allow Subversion to manage
      your data, then this is a feature you'll eventually come to
      depend on.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-1">
    <title>What's a branch?</title> 

    <para>A good way to explain the idea of a "branch" is with an
    example.</para>

    <para>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      'tweaked' for their specific department, since they do things
      slightly differently.</para>

    <para>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      specific changes, you incorporate them into one copy or the
      other.</para>

    <para>Of course, often you want to make the same change to *both*
      copies.  For example, if you discover a typo in the first copy,
      it's very likely that the same typo exists in the second copy.
      The two documents are almost the same, after all; they only
      differ in small, specific ways.</para>

    <para>This is the basic concept of a <firstterm>branch</firstterm>
      &mdash; namely, a line of development that exists independently of
      another line, yet still shares a common history if you look far
      enough back in time.  A branch always begins life as a copy of
      something, and moves on from there, generating its own
      history.</para>

      <figure id="svn-ch4-dia1">
        <title>Branches of development</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      "mix and match" different lines of development in your daily
      work.</para>

  </sect1>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-2">
    <title>Creating a branch</title> 

    <para>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a "revision") in the
      repository.  If not, go back and read about revisions in  <xref
      linkend="svn-ch-2-sect-3.2"/>.</para>

    <para>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Felix, are
      sharing a repository that contains two projects,
      <filename>trunk</filename> and <filename>write.</filename>
      Notice, however, that this time somebody has created two new
      top-level directories in the repository, called
      <filename>trunk</filename> and <filename>branches</filename>.
      The projects themselves are subdirectories of
      <filename>trunk</filename>, and the reason for this will become
      clearer later on.</para>
    
      <figure id="svn-ch4-dia2">
        <title>Starting repository layout</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para>As before, assume that you and Felix both have working
      copies of the <filename>/trunk/write</filename> project.</para>

    <para>Let's say that you've been given the task of performing a
      radical reorganization of the project.  Not only is it a wide
      change (it will affect all the files in the project), but it's a
      very large change (it will take a long time to write.)  The
      problem here is that you don't want to interfere with Felix, who
      is in the process of fixing small bugs here and there.  He's
      depending on the fact that the latest version of the project is
      always usable.  If you start committing your changes as you make
      them, you'll surely "break" the project for Felix.</para>

    <para>One strategy is to simply crawl into a hole: you and Felix
      can stop sharing information for a week or two.  That is, start
      gutting and reorganizing all the files in your working copy, but
      don't commit or update until you're completely finished with the
      task.  There are are number of problems with this, though.
      First, it's not very safe.  Most people like to save their work
      to the repository frequently, should something bad accidentally
      happen to their working copy.  Second, it's not very flexible.
      If you do your work on different computers (perhaps you have a
      working copy of <filename>/trunk/write</filename> on two
      different machines), you'll need to manually copy your
      long-running changes back and forth, or just do all the work on
      a single computer.  Finally, when you're finished, you might
      find it very difficult to commit.  Felix (or others) may have
      made many changes in the repository that are difficult to merge
      into your working copy -- especially all at once.</para>

    <para>The better solution, of course, is to create your own
      branch, or line of development, in the repository.  This allows
      you to save your half-broken work frequently without interfering
      with others, yet you can still selectively share information
      with your collaborators.  You'll see exactly how this works
      later on.</para>

    <para>So how do we create a branch?  Very simple -- you make a
      copy of the project in the repository using the <command>svn
      copy</command> command.  Subversion is not only able to copy
      single files, but whole directories as well.  In this case, you
      want to make a copy of the <filename>/trunk/write</filename>
      directory.  Where should the new copy live?  It doesn't really
      matter; Subversion doesn't care.  It's a matter of project
      policy.  Let's say that your team has a policy of creating
      branches in the <filename>/branches</filename> area of the
      repository.  So you want to create a new directory,
      <filename>/branches/my-write-branch</filename>, which starts as
      a copy of <filename>/trunk/write</filename>. </para>

    <para>There are two different ways to make a copy.  We'll
      demonstrate the messy way first, just to make the concept clear.
      To begin, check out a working copy of the root
      (<filename>/</filename>) of the repository:</para>

<screen>
$ svn checkout http://svn.example.com/repos/ bigwc
A  bigwc/branches/
A  bigwc/trunk/
A  bigwc/trunk/write
A  bigwc/trunk/write/Makefile
A  bigwc/trunk/write/document.c
A  bigwc/trunk/write/search.c
A  bigwc/trunk/paint
A  bigwc/trunk/paint/Makefile
A  bigwc/trunk/paint/canvas.c
A  bigwc/trunk/paint/brush.c
Checked out revision 340.
</screen>

    <para>And now it's simply a matter of passing two working-copy
      paths to the <command>svn copy</command> command:</para>

<screen>
$ cd bigwc
$ svn copy trunk/write branches/my-write-branch
$ svn status
A  +   branches/my-write-branch
</screen>

    <para>In this case, the <command>svn copy</command> command
    recursively copied the <filename>trunk/write</filename> directory
    to a new directory, <filename>branches/my-write-branch</filename>.
    As you can see from the <command>svn status</command> command, the
    new directory is now scheduled for addition to the repository.
    But also notice the '+' next to the letter A.  This indicates that
    the scheduled addition is a <emphasis>copy</emphasis> of
    something, not something new.  When you commit your changes,
    Subversion will create
    <filename>/branches/my-write-branch</filename> in the repository
    by copying <filename>/trunk/write</filename>, rather than
    resending all of the working copy data over the network.</para>

<screen>
$ svn commit -m "Creating a private branch of /trunk/write."
Adding      branches/my-write-branch
Committed revision 341.
</screen>

    <para>And now the easier method of creating a branch, which we
      should have told you about in first place: the <command>svn
      copy</command> is able to operate on two URLs.</para>

<screen>
$ svn copy http://svn.example.com/repos/trunk/write \
           http://svn.example.com/repos/branches/my-write-branch \
      -m "Creating a private branch of /trunk/write"

Committed revision 341.
</screen>

    <para>From Subversion's point of view, there's absolutely no
    difference between these two methods.  Both procedures end up
    creating a new directory in revision 341, and the new directory is
    a copy of <filename>/trunk/write</filename>.  Notice that the
    second method, however, performs an <emphasis>immediate</emphasis>
    commit.  It's an easier procedure, because it doesn't require you
    to check out a large mirror of the repository.  In fact, this
    technique doesn't even require you to have a working copy at all!
    </para>

    <figure id="svn-ch4-dia3">
      <title>Repository with new copy</title>
      <graphic fileref="images/ch04dia3.png"/>
    </figure>
    
    <sidebar>
      <title>Cheap copies</title>
      
      <para>At this point, you might be thinking to yourself: "Holy
        cow, the repository is copying entire directories -- doesn't
        that mean that the repository will get really huge if you
        start making branch-copies of big projects?"</para>

      <para>This is a valid concern!  However, no need to worry.
        Subversion's repository has a clever internal design.  When
        the repository copies something, it doesn't actually duplicate
        any data.  Instead, it creates a new directory entry that
        points to an <emphasis>existing</emphasis> tree.  If you're a
        Unix user, this is the same concept as a hard-link.  From
        there, the copy is said to be "lazy".  That is, if you commit
        a change to one file within the copied directory, then only
        that file changes -- the rest of the files continue to exist
        as hard-links to the original files in the original
        directory.</para>
      
      <para>This is why you'll often hear Subversion users talk about
        "cheap copies".  It doesn't matter how large the directory is
        -- it takes a very tiny, constant amount of time to make a
        copy of it.  In fact, this feature is the basis of how commits
        work in Subversion: each revision is a "cheap copy" of the
        previous revision, with a few items lazily changed within.  To
        read more about this, look at Subversion's Design document.
        <!-- ### link?  is this in the book?  URL? --></para>

      <para>The moral of the story is: copies are cheap, both in of
        time and space.  Make branches as early and often as you want
        to.</para>
    </sidebar>

    <para>EVERTHING BELOW HERE IS BEING REWRITTEN</para>

    <para>Suppose we have a repository whose head tree is revision 82.
      In this repository is a subdirectory <filename>mooIRC</filename>
      that contains a software project that is ready to be tagged.
      How do we tag it?  Very simple: make a <quote>cheap</quote> copy
      of this directory.  In other words, create a new directory entry
      (somewhere else in the filesystem) that points to this
      <emphasis>specific</emphasis> node that represents directory
      <filename>mooIRC</filename> in revision 82.  Of course, you can
      name the new directory entry whatever you want -- probably a
      tag-name like <filename>mooIRC-beta</filename>.</para>
    
    <para>The easiest way to make this copy is with <command>svn
      cp</command>, which, incidentally, can operate entirely on URLs,
      so that the copy happens only on the server-side:</para>

    <screen>
      $ svn cp http://foo.com/repos/mooIRC http://foo.com/repos/mooIRC-beta
      Committed revision 83.
    </screen>

    <para>Now, as long as you never touch the contents of the
      directory <filename>mooIRC-beta</filename>, that entry will
      forever point to a node that looks the way
      <filename>mooIRC</filename> did at a specific moment in time
      (however it looked in revision 82).  And that's exactly what a
      <firstterm>tag</firstterm> is.</para>

    <para>But suppose <filename>mooIRC-beta</filename> isn't sacred,
      and instead you decide to start making commits to it.  And
      suppose you <emphasis>also</emphasis> continue to make commits
      in the original <filename>mooIRC</filename> directory.  Then you
      have two directories that started out looking identical -- their
      common ancestor was <filename>mooIRC</filename> in revision 82
      -- but now have diverged their contents over time.  In other
      words, they represent different <firstterm>branches</firstterm>
      of the project.</para>

    <para>It's very important to note that the Subversion filesystem
      is <emphasis>not</emphasis> aware of <quote>tags</quote> or
      <quote>branches.</quote> It's only aware of directories, and all
      directories are equal.  The tag and branch concepts are purely
      <emphasis>human</emphasis> meanings attached to particular
      directories.</para>

    <para>For this reason, it's up to users (and the Subversion
      repository administrator) to choose sane policies that help
      elucidate these labels.  For example, here's a good way to lay
      out your repository:</para>

    <screen>
      /
      /projectA
      /projectA/trunk/
      /projectA/branches/
      /projectA/tags/
      /projectB
      /projectB/trunk/
      /projectB/branches/
      /projectB/tags/
    </screen>

    <para>Each time <filename>/projectA/trunk</filename> reaches a
      taggable state, make a copy of the directory somewhere in
      <filename>/projectA/tags/</filename>, and set the copy to
      read-only.  Use the same procedure to create a branch in
      <filename>/projectA/branches/</filename>.</para>

    <para>An alternate way to lay out a repository:</para>

    <screen>
      /
      /trunk
      /trunk/projectA
      /trunk/projectB
      /branches
      /branches/projectA
      /branches/projectB
      /tags
      /tags/projectA
      /tags/projectB
    </screen>

    <para>Or, of course, you could just place each project into a
      dedicated repository.  It's up to you.  For examples on how to
      create a repository with one of these structures, <xref
      linkend="svn-ch-5"/><!-- ###TODO Make this xref (Creating a
      repository) more specific -Fitz -->.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-3">
    <title>Switching to a Branch with svn switch</title>

    <para>The <command>svn switch</command> command allows you to
      <quote>move</quote> some or all of your working copy to a branch
      or tag.  For example, suppose I have a working copy of
      <filename>mooIRC</filename>, and I'd like to work on some
      subsystem as it appears in a subdirectory of
      <filename>mooIRC-beta</filename>.  At the same time, I want the
      rest my working copy to remain on the original
      <filename>mooIRC</filename> branch.  To do this, I switch the
      appropriate subdir to the new branch location:</para>

    <screen>
      $ svn switch http://foo.com/repos/mooIRC-beta/subsystems/renderer \
                   mooIRC/subsystems/renderer
      
      U  mooIRC/subsystems/renderer/foo.c
      U  mooIRC/subsystems/renderer/bar.h
      U  mooIRC/subsystems/renderer/baz.c
    </screen>

    <para>Now my working copy of the <filename>renderer</filename>
      subdirectory represents a different location on the
      server.</para>

    <para>Really, <command>svn switch</command> is just a fancier
      version of <command>svn update</command>.  Whereas <command>svn
      update</command> has the ability to move your working copy
      through time (either by updating to the latest revision, or by
      updating to a specific revision given with
      <option>-r</option>), <command>svn switch</command> is
      able to move your working copy through time
      <emphasis>and</emphasis> space.</para>

    <para>If your working copy contains a number of
      <quote>switched</quote> subtrees from different repository
      locations, it continues to function as normal.  When you update,
      you'll receive patches to each subtree as appropriate.  When you
      commit, your local changes will still be applied as a single,
      atomic change to the repository.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-4">
    <title>Moving changes with svn merge</title>

    <para>Suppose a team of programmers working on the
      <filename>mooIRC-beta</filename> branch have fixed a critical
      bug, and the team working on the original
      <filename>mooIRC</filename> branch would like to apply that
      change as well.</para>

    <para>The <command>svn merge</command> command is the answer.  You
      can think of <command>svn merge</command> as a special kind of
      <command>svn diff</command>; only instead of displaying unified
      diffs to the screen, it <emphasis>applies</emphasis> the
      differences to your working copy as if they were local
      changes.</para>

    <para>For example, suppose the bug fix happened in a commit to the
      <filename>mooIRC-beta</filename> branch in revision 102.</para>
    
    <screen>
      $ svn diff -r 101:102 http://foo.com/repos/mooIRC-beta
      
     &hellip;   # diffs sent to screen
      
      $ svn merge -r 101:102 http://foo.com/repos/mooIRC-beta mooIRC
      U   mooIRC/glorb.c
      U   mooIRC/src/floo.h
    </screen>

    <para>While the output of <command>svn merge</command> looks
      similar to <command>svn update</command> or <command>svn
      switch</command>, it is in fact only applying temporary changes
      to the working files.  Once the differences are applied as local
      changes, you can examine them as usual with <command>svn
      diff</command>, <command>svn status</command>, or undo them with
      <command>svn revert</command> as usual.  If the changes are
      acceptable, you can commit them.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-5">
    <title>Rolling back a change with svn merge</title>

    <para>Another common use for <command>svn merge</command> is for
      rolling back a change that has been committed.  Say you commit
      some changes in revision 10, and later decide that they were a
      mistake.  You can easily revert the tree to the state it was in
      at revision 9 with an <command>svn merge</command>
      command.</para>

    <screen>
      $ svn commit -m "change some stuff"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 10.
      $
      
      &hellip; # developer continues on and realizes he made a mistake
      
      $ svn merge -r 10:9 .
      U ./bar.c
      U ./foo.c
      $ svn commit -m "oops, reverting revision 10"
      Sending        bar.c
      Sending        foo.c
      Transmitting file data ..
      Committed revision 11.
    </screen>
    
    <para>If you aren't rolling back the changes to your current
      directory (say you want to roll back one specific file, or all
      the files in one specific subdirectory), then the syntax is
      slightly different, as you have to tell <command>svn
      merge</command> where it should merge the changes into.</para>

    <screen>
      $ svn merge -r 10:9 baz/ baz/
      U ./baz/bar.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 10's changes in baz/"
      Sending        baz/bar.c
      Sending        baz/foo.c
      Transmitting file data ..
      Committed revision 12.
      $
      
      &hellip; # developer continues on and later makes another mistake
      
      $ svn merge -r 13:12 baz/foo.c baz/foo.c
      U ./baz/foo.c
      $ svn commit -m "reverting revision 12's change to foo.c"
      Sending        baz/foo.c
      Transmitting file data .
      Committed revision 15.
    </screen>
    
    <para>Keep in mind that rolling back a change like this is just
      like any other <command>svn merge</command> operation, so you
      should use <command>svn status</command> and <command>svn
      diff</command> to confirm that your work is in the state you
      want it to be in, and then use <command>svn commit</command> to
      send the final version to the repository.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-6">
    <title>Removing a Branch or Tag with svn rm</title>

    <para>The <command>svn rm</command> command can operate on URLs.
      A file or directory can be <quote>remotely</quote> deleted from
      the repository, with no working copy present:</para>

    <screen>
      $ svn rm http://foo.com/repos/tags/mooIRC-bad-tag -m "deleting bad tag"
      Committed revision 1023.
    </screen>

    <para>Of course, this is still a form of immediate commit, so some kind of
      log message is still required.</para>

    <para>Enough said!</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->


