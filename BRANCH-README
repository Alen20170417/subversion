A branch on which to try out move-tracking designs.

Merge policy:

  Development branch -- periodic catch-up merges from trunk.

  The work on this branch may or may not eventually be wanted on trunk. It
  is not intended to be kept in a state where it could be merged to trunk.

  Please don't review for implementation issues, not even big-O
  complexity concerns etc. at this time.

  Please do try it out.

  If you can help me get my head around how the logic should work, I'd be
  extremely glad of any discussion of that.


Work on this branch:

  * A proof-of-concept utility for playing with moves and branching
    to see how well the logic works out in practice.

    It's called 'svnmover'. Like 'svnmucc', it operates directly on a repo,
    completely avoiding any working copy considerations.

    The implementation is just a hack. It stores metadata in revprops
    or flat files , with little concern for efficiency etc. at this
    stage.

    STATUS

    This is my current focus.

    Implemented:
      basic edits including move, copy, delete
      branching: branch, list-branches
      diff
      merge

    UI things to do:
      provide a way to specify a mixed-rev base state
      provide a UI for element-based addressing ('mv e101:foo e103:foo'?)

    Bigger things to do:
      "replay": convert committed changes to an edit drive
      heuristic conversion of old repositories:
        synthesize element tracking info (instead of aborting) when reading
        a revision that was committed by a non-move-tracking client


  * The model.

    To do:
      clarify the sequencing requirements of editing: for example,
        requesting the full path to an element implies finalization of
        at least it and all its parent elements
      copying: model copying as a (tree) relationship between elements
        that is the same across all branches in a family?


  * A 'commit editor' interface supporting moves

    STATUS

    First I tried:

        Type 1: stateful/incremental; path-based addressing

        (subversion/include/private/svn_editor3p.h)

    This is an evolution of the old delta editor, trying to add on moves.
    Starting from an Ev1 code base, this one seems easier to start using,
    as the style is more familiar.

    Ev1->Ev3->Ev1 shims are written, using the 'incremental' API. Tests
    pass with double-shim conversions at RA layer and repos layer. (One
    svnlook test fails due to svnlook reporting a no-op change as a
    change.)

    However, this version of the editory is not complete with respect to
    branching: it only provides the operations that are needed *within* a
    branch. It could, I suppose, be extended to support operations on
    branches, including both the 'branching' operation itself, and also
    dealing with sub-branches found in the scope of subtree operations
    such as move, copy, and delete.

    However, now I believe the future lies in:

        Type 2: stateless/independent per-element changes

        (subversion/include/private/svn_element.h,
         subversion/include/private/svn_branch.h,
         subversion/include/private/svn_editor3e.h)

    (The functionality is currently partially encapsulated in
    an 'editor' class with a vtable of methods, and partially
    provided as plain functions in svn_branch.h. This needs to be
    sorted out.)

    I think this one is ultimately better and easier to use.

    I think it's not a question of one way is right and one is wrong;
    rather, both are possible correct approaches.


  * Adapt the editor as necessary to use as an 'update editor'.

    The 'update editor' has some significantly different requirements,
    at least the way it's implemented today with WC paths being
    communicated rather than repository paths/nodes. Need to work out
    how best to achieve this.
    My preference is to lean towards using a 'tree editor' working on
    repos nodes, and let the client side convert these to WC paths, but
    we'll have to see if that's practical.

    STATUS

    Not started.


  * 'update'

    STATUS

    Needs design.


Terminology:

  'Ev3'/'svn_editor3_t' is a temporary name. It should end up
  replacing Ev2 and so should be called 'Ev2'/'svn_editor_t' then.
  Or perhaps 'svn_branch[ing]_editor'.

  'branch sibling' -> 'branch segment'?

  'branch instance' -> 'branch rev'/'branch txn'/'branch version'?
