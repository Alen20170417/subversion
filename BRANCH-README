A branch on which to prototype a model of move-tracking and branching.

Merge policy:

  Development branch -- periodic catch-up merges from trunk.

  The work on this branch may or may not eventually be wanted on trunk. It
  is not intended to be kept in a state where it could be merged to trunk.


Reviewing:

  Please do try out the 'svnmover' utility, explore how branching and
  subbranching and moving interact, and review and discuss the behavioural
  aspects of the model being prototyped here.

  Please don't review for 'quality of implementation' issues, not even
  big-O complexity concerns etc. The goal of this work is for us to learn
  about the behavioural model that we want. Designing a proper
  implementation will come later.


The model:

    Imagine a user who:

      - is familiar with version control concepts
      - is not familiar with Subversion specifics
      - expects directories to be versioned (not just files)
      - expects move tracking (as opposed to move 'detection')

    The design aims to satisfy such a user.


BUGS:

  * merge doesn't detect 'clashes' (same path exists more than once):
    - mkdir a
    - commit
    - update .@(head - 1)   # should report a conflict, but doesn't
    - mkdir a           # has a different element number
    - update .@head     # now two paths 'a' exist
    - commit            # should fail


Work on this branch:

  * 'svnmover'

    A proof-of-concept utility for playing with moves and branching.
    'svnmover' is a user interface that lets us try out scenarios in
    which branching and moving are significant, to see what we expect
    and see if we can write code that delivers it.

    'svnmover' operates directly on a repo, like 'svnmucc'. Working copy
    considerations -- mixed-rev states, sparse checkouts, conflicts, and
    so on -- are completely avoided. A working copy is, in essence, a tool
    for viewing and making changes to the versioned data, and so needs to
    be designed to support the versioned data model. That comes *after*
    designing the data model. Working copy considerations may be introduced
    to 'svnmover' in due course in order to explore how they would work.

    'svnmover' processes a series of commands given on the command line, and
    then commits the result. In interactive mode (when run with no command
    arguments) it makes one commit per line of input.

    The implementation stores metadata either in revprops or in flat files
    in the repository directory; the metadata is the same in either case.

    STATUS

    This is my current focus.

    Implemented:
      basic edits: add file/dir, move, copy, delete
      branching: branch, create new branch, list branches
      diff
      merge

    UI things to do:
      add a 'parallel mode' UI as an alternative to the sequential mode
      provide a way to specify a mixed-rev base state
      provide a UI for element-based addressing ('mv e101:foo e103:foo'?)

    Bigger things to do:

      Build a mock WC:

        1. "Check out" a given rev by starting an in-memory txn based
          on that rev.

        2. Make edits in this txn.

        3. Start a commit, get a new txn based on repository head.

        4. Replay the WC txn's changes into the commit txn, and commit it.

      "Replay" API: convert committed changes to an edit drive

        * A txn must keep track of which EIDs in it were previously
          known and which are new in that txn.

        * The 'replay' function must tell the driven editor which EIDs
          are previously known and which are to be considered as new.

        * The editor API must accept "new" EIDs in all EID contexts:
          including as a parent-eid, or as a subtree-root eid, not only
          as the primary EID of the element the method is operating on.
          That will allow the operations on elements to come in truly
          independent order: it will not be necessary to 'create' a
          directory before any other operation can refer to that
          directory's new EID as a parent-eid, for example.

        * The editor must translate incoming 'new' EIDs if they are not
          already unique between the edit driver and edit receiver. For
          example, if the driver knows EIDs [0..60] are pre-existing, and
          chooses to use EIDs [61...] for 'new' elements, and the
          receiver's txn already uses EIDs [0..70] then it must translate
          incoming EIDs [61..70] to some other range.

      heuristic conversion of old repositories:
        synthesize element tracking info (instead of aborting) when reading
        a revision that was committed by a non-move-tracking client

    Tidying things to do:

      Combine editor3 methods 'alter' and 'add' into a single method.

        They have basically the same meaning apart from the precondition
        (element does or does not already exist). The pre-existence should
        *not* be considered, I think, because ... idempotency?
        Likewise, 'delete' should not care if it was already deleted.
        The unifying principle is it's communicating a partial description
        of the new state, without reference to the old state.

      Create editor vtable methods for all editor interface functions.

        Currently, some functions bypass the vtable. They are broken if
        they use the editor private data structure and if they are invoked
        on a wrapper editor (such as the 'debug editor') because in that
        case they dereference the wrapper editor's private data struct
        instead of the intended editor's.

  * The model.

    To do:
      clarify the sequencing requirements of editing: for example,
        requesting the full path to an element implies finalization of
        at least it and all its parent elements
      copying: model copying as a (tree) relationship between elements
        that is the same across all branches in a family?

      editor should be an editor of a txn based on a base state
        * Should not know about 'the repository' and other revisions,
          so these functions should not be 'editor' methods:
            svn_editor3_get_all_branches_in_rev()
            svn_editor3_find_el_rev_by_path_rev()


  * A 'commit editor' interface supporting moves

    STATUS

    First I tried:

        Type 1: stateful/incremental; path-based addressing

        (subversion/include/private/svn_editor3p.h)

    This is an evolution of the old delta editor, trying to add on moves.
    Starting from an Ev1 code base, this one seems easier to start using,
    as the style is more familiar.

    Ev1->Ev3->Ev1 shims are written, using the 'incremental' API. Tests
    pass with double-shim conversions at RA layer and repos layer. (One
    svnlook test fails due to svnlook reporting a no-op change as a
    change.)

    However, this version of the editory is not complete with respect to
    branching: it only provides the operations that are needed *within* a
    branch. It could, I suppose, be extended to support operations on
    branches, including both the 'branching' operation itself, and also
    dealing with sub-branches found in the scope of subtree operations
    such as move, copy, and delete.

    However, now I believe the future lies in:

        Type 2: stateless/independent per-element changes

        (subversion/include/private/svn_element.h,
         subversion/include/private/svn_branch.h,
         subversion/include/private/svn_editor3e.h)

    (The functionality is currently partially encapsulated in
    an 'editor' class with a vtable of methods, and partially
    provided as plain functions in svn_branch.h. This needs to be
    sorted out.)

    I think this one is ultimately better and easier to use.

    I think it's not a question of one way is right and one is wrong;
    rather, both are possible correct approaches.


  * Adapt the editor as necessary to use as an 'update editor'.

    The 'update editor' has some significantly different requirements,
    at least the way it's implemented today with WC paths being
    communicated rather than repository paths/nodes. Need to work out
    how best to achieve this.
    My preference is to lean towards using a 'tree editor' working on
    repos nodes, and let the client side convert these to WC paths, but
    we'll have to see if that's practical.

    STATUS

    Not started.


Terminology:

  'Ev3'/'svn_editor3_t' is a temporary name. It should end up
  replacing Ev2 and so should be called 'Ev2'/'svn_editor_t' then.
  Or perhaps 'svn_branch[ing]_editor'.

