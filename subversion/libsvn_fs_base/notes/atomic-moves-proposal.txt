              .:  SVN_FS_RENAME:  A DESIGN PROPOSAL :.

CONVENTIONS

    Below, the term "move" means what has in the past been referred to
    as an "atomic move", "atomic rename", "true move", "true rename",
    and so on.  It does *not* refer to the Subversion command-line
    client's "move" subcommand, nor to the combined copy and delete
    operations of which that subcommand is currently comprised.
    
    Also, I will be speaking only about the Berkeley DB backend.  I
    believe the document also applies to the FSFS backend, but am not
    entirely sure of that.  So for now, I'll stick with what I know.

THE GOALS

    * A move should be a first-class atomic operation, unlike the
      copy+delete manifestation that exists today (of which only one
      of the copy or delete might succeed).
  
    * A move is an operation on the directory entries lists of the
      source and destination parents, *not* an operation on the object
      being moved.  An examination of a versioned target before and
      after a move must find it unchanged, merely relocated.
  
    * A move should be easily detectable after the fact, that is,
      distinguishable from a [copy-with-history + delete].

THE NAIVE APPROACH (AND WHY IT WON'T WORK)

    In early 2003, Philip Martin posted a patch for the naive
    implemenation of svn_fs_rename().  The algorithm was what you'd
    expect: in a single Berkeley DB transaction, update the directory
    entry lists of the source and target containing directories, such
    that the source no longer referred to the node revision ID of the
    moved object, and the target did.  And to be sure (I mean, it *is*
    Philip Martin), the code behaved as expected.
    
    Most of the time.
  
    The problem with the naive approach lies in how we construct node
    revision IDs.  The node revision ID schema in Berkeley DB is:
    
       NODE_ID.COPY_ID.TXN_ID
    
    where:
    
       - NODE_ID identifies a unique tree of versioned history.  Node
         revision's which have the same NODE_ID necessarily share an
         ancestor, but are not necessarily ancestors of each other.
    
       - COPY_ID identifies the copy operation responsible for the
         creation of a particular fork in a line of history.
     
       - TXN_ID identifies the transaction in which a given node
         revision came into existence.
    
    In Subversion, a copy operation is the only way to cause a line of
    versioned history to be represented by more than one object in a
    given revision.  Because of copies, you may have in a given
    revision several different node revisions sharing the same NODE_ID
    (when a node revision is copied, the newly created target node
    keeps the NODE_ID of the source node, as do all its successors).
    And if you chose to change any two of those in the same
    transaction, their successors would also have the same TXN_ID.
    Fortunately, the two copies would get different COPY_ID
    components, thus preventing completely identical node revision
    IDs.
    
    When a node revision is copied, a new copy record (keyed on
    COPY_ID) is written to the 'copies' table contain details of the
    copy, and the new target node gets that COPY_ID.  As children
    (directory-wise descendants) of that copy target are modified in
    the future, they inherit that COPY_ID, so that Subversion can
    identify that the reason that tree exists at all is due to that
    copy, and so that nodes in the tree that represents the source of
    that copy and nodes in the tree of the copy target cannot possibly
    have identical node revision IDs.  The promise provided is that
    whenever a single line of history incurs a change in tree location
    (the path), there is also an associated change in the COPY_IDs
    used by objects in that line of history, and in the directory
    case, by objects which are children (and grandchildren, etc) of
    that directory.
    
    Along comes Philip's svn_fs_rename() implementation, and suddenly
    the promise no longer holds.  Suddenly a line of history could
    incur a change in tree location without a change in the COPY_ID.
    The broken promise is devastating.  With just a few simple
    operation, you can now wind up with more than one node revision
    slated to have the same node revision ID.  A recipe is posted
    here:
    
        http://subversion.tigris.org/issues/show_bug.cgi?id=898#desc10
    
    As you can see, modifying both copies of bar.c in the same
    transaction (4) would yield two different node revisions, yet both
    would get the same node revision ID, "3.0.4".  In fact, you
    wouldn't even get that far in the recipe, because bar's parent
    directory (/branches/foo, or /trunk/bloo, depending on which way
    you crawl the tree) would also suffer a collision, on the node
    revision ID 2.0.4.
    
    Clearly, the naive implementation is insufficient by itself.  The
    other solutions proposed in that issue are also unattractive, for
    various reasons; anyway, a good solution is available.
  
THE IMPROVED APPROACH
  
    Do things exactly the way Philip's patch does, but add these two
    details:
    
       * When a move occurs, a new row is added to the 'copies' table,
         with a new "move" operation indicator, the source path, the
         destination path, and the transaction:
    
            ("move" SRC-PATH DST-PATH TXN-ID)
    
       * When the moved object's node revision ID is being added to
         the destination directory's entries list, the entry is
         annotated with the ID of the new 'copies' table row.  Note
         that's "entry", not "node revision": we're attaching metadata
         to a directory entry itself, not to the thing the entry
         refers to.  The new definition of an ENTRY would be:
    
            (NAME NODE-REVISION-ID [MOVE-ID])
    
    The presence of the MOVE-ID on the entry NAME means that the first
    time the directory's child NAME is modified, the newly-created
    node revision ID should have its COPY-ID set to the value of the
    MOVE-ID (and of course keep the same NODE-ID as its predecessor,
    and get the TXN-ID of the current txn).  Then the
    (now-cloned-for-mutability) container directory's entry list has
    the MOVE-ID removed from NAME's entry in that list, to indicate
    that this one-time delayed inheritance has occured.
    
    Besides meeting the criteria for a true move, this system:
    
       * Preserves node revision ID uniqueness via COPY-ID
    
       * Offers move detection compatible with the existing history
         algorithm.  The only difference is that the COPY-ID might
         point to a move instead of to a copy.

QUESTIONS/ANSWERS

    Q: What happens if a directory with a move-id-having entries list
       is copied, or itself moved?  Do we need a soft-move concept
       like the soft-copy one?

    A: No.  See http://svn.haxx.se/dev/archive-2006-03/0712.shtml for
       the details of why.

    --

    Q: Seems like there is a whole lotta work to get to the place
       where a Subversion client can perform an atomic move
       operation.  Won't that make debugging and testing the
       filesystem code hard?

    A: Yes.  That's why tools/dev/svn-move exists (you'll need to
       build the Python bindings).

TODO (LIKELY INCOMPLETE)

    * Make sure that we don't carry around delayed move ID information
      on entries where not necessary.

      * The question here is about cases like this:

        move /some/subdir /some/new-subdir
        copy /some /other

        When we do the move we add a delayed move ID tag on the new
        entry.  What should happen to it later when we do the copy?
        The answer is currently unclear.

      * Some thoughts: we can't just drop the move-id on that copy,
        Since that would imply that we'd need to go looking for it.
        But we've gotta do something because otherwise we end up in
        situations where we have multiple new nodes trying to use that
        copy id, resulting in primary key conflicts.

        The fix for this that we're using now is to introduce alias
        records in the copies table that point to the actual copy we
        want to reference.  This avoids the issue, but we should
        really only be doing it when necessary, i.e. when a parent dir
        has been copied since our move occurred, not all the time,
        since it introduces some extra work traversing history later
        on due to the extra level of indirection.

    * Figure out what parts of the source tree that are depending on 
      nodes changing when something is moved.

    * Dump/Load support needs to be finished.  It sort of works, but
      there are edge cases related to nested moves (see the multiple
      moves test in svnadmin_tests.py).

    * History tracing doesn't seem to be interacting well with copies,
      see copy_then_moves_test in fs-test.c).
