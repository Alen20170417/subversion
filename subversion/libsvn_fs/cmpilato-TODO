=============================================================================
THOTZ: (by cmpilato, on conversion to the new NodeRevId system)
              *** do not merge me into the main trunk **
=============================================================================

There is a single use of svn_fs_id_distance() in merge that needs
examination.  svn_fs_id_distance is being used as a relatedness check,
but (and this is a general issue in the filesystem code)
svn_fs_id_distance *used* to claim that copied things were unrelated
to their sources, and this is no longer the case.  All users of
svn_fs_id_distance need to be examined to see if this changed concept
of relatedness effects their particular use of svn_fs_id_distance.

--

Deltification is currently the only process in place that asks the
question, "Where is my next successor?"  Currently the question is
answered by doing a little node revision id mathematics; that's no
longer an option.  Input to deltification is still root/path, so what
might a new algorithm be?

This from Bill Tutt:

   This is kind of funky now. A portion of the answer is very similar
   to the problem of "What should my CopyID be for a new NodeRevision
   I need to create now?"
   
   The solution to this general question (as you noticed elsewhere) is
   to acquire it during your path walk.  i.e.: 
   svn_fs_node_id (&(args.id), root, path, pool)
   
   The other funky part is taking this "successor CopyID" calculation
   in combination with the TxnID ordering.
   
      get TXN_ID from node revision id.
      Lookup REVISION with TXN_ID
      I = 1
      Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
      While REVISION+I is valid 
            AND Not Exists NodeID.<calculated
      CopyID>.POSSIBLE_SUCCESSOR_TXN_ID:
         I++
         Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
   
   If you find a NodeRevision that exists, you've found your
   successor, and you should be able to assert that the predecessor is
   the NodeRevision you started from.
   
   Otherwise there is no possible successor.

Need to actually solve this problem for the `svnadmin deltify' case.

While it's perfectly fine to deltify a thing against its immediate
successor, it could be more beneficial if deltified against the
youngest successor of the thing.

--

Need to examine the copy_id choosing algorithm in open_path().
