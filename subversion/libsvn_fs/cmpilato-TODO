=============================================================================
THOTZ: (by cmpilato, on conversion to the new NodeRevId system)
              *** do not merge me into the main trunk **
=============================================================================

There is a single use of svn_fs_id_distance() in merge that needs
examination.  svn_fs_id_distance is being used as a relatedness check,
but (and this is a general issue in the filesystem code)
svn_fs_id_distance *used* to claim that copied things were unrelated
to their sources, and this is no longer the case.  All users of
svn_fs_id_distance need to be examined to see if this changed concept
of relatedness effects their particular use of svn_fs_id_distance.

--

Deltification is currently the only process in place that asks the
question, "Where is my next successor?"  Currently the question is
answered by doing a little node revision id mathematics; that's no
longer an option.  Input to deltification is still root/path, so what
might a new algorithm be?

This from Bill Tutt:

   This is kind of funky now. A portion of the answer is very similar
   to the problem of "What should my CopyID be for a new NodeRevision
   I need to create now?"
   
   The solution to this general question (as you noticed elsewhere) is
   to acquire it during your path walk.  i.e.: 
   svn_fs_node_id (&(args.id), root, path, pool)
   
   The other funky part is taking this "successor CopyID" calculation
   in combination with the TxnID ordering.
   
      get TXN_ID from node revision id.
      Lookup REVISION with TXN_ID
      I = 1
      Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
      While REVISION+I is valid 
            AND Not Exists NodeID.<calculated
      CopyID>.POSSIBLE_SUCCESSOR_TXN_ID:
         I++
         Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
   
   If you find a NodeRevision that exists, you've found your
   successor, and you should be able to assert that the predecessor is
   the NodeRevision you started from.
   
   Otherwise there is no possible successor.

Need to actually solve this problem (at least enough to get the
per-commit deltification working again).

While it's perfectly fine to deltify a thing against its immediate
successor, it could be more beneficial if deltified against the
youngest successor of the thing.

--

Need to examine the copy_id choosing algorithm in open_path().

--

Hm...looks like we can't remove the stabilization walk until we find a
better time to mark our representations as immutable, or stop using a
mutability flag on those skels.  Major disappointment.

AH!  Of course.  I think the representations need only to store a
TXN_ID (instead of a mutability flag) and simply compare that with the
current transaction ID as a mutability test, just like the node
revisions will.  *That* should eliminate the stabilization walk, since
the minute the txn is committed, all those reps become effectively
immutable.
