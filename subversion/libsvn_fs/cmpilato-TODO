=============================================================================
THOTZ: (by cmpilato, on conversion to the new NodeRevId system)
              *** do not merge me into the main trunk **
=============================================================================

Deltification is currently the only process in place that asks the
question, "Where is my next successor?"  Currently the question is
answered by doing a little node revision id mathematics; that's no
longer an option.  Input to deltification is still root/path, so what
might a new algorithm be?

This from Bill Tutt:

   This is kind of funky now. A portion of the answer is very similar
   to the problem of "What should my CopyID be for a new NodeRevision
   I need to create now?"
   
   The solution to this general question (as you noticed elsewhere) is
   to acquire it during your path walk.  i.e.: 
   svn_fs_node_id (&(args.id), root, path, pool)
   
   The other funky part is taking this "successor CopyID" calculation
   in combination with the TxnID ordering.
   
      get TXN_ID from node revision id.
      Lookup REVISION with TXN_ID
      I = 1
      Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
      While REVISION+I is valid 
            AND Not Exists NodeID.<calculated
      CopyID>.POSSIBLE_SUCCESSOR_TXN_ID:
         I++
         Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
   
   If you find a NodeRevision that exists, you've found your
   successor, and you should be able to assert that the predecessor is
   the NodeRevision you started from.
   
   Otherwise there is no possible successor.

--

svn_fs__new_node_id: needs a txn_id, but not a copy id.  If something
was copied, it has a successor id.  node id is chosen as the next
available node id in the `nodes' table.

svn_fs__new_node_id is called only by svn_fs__create_node, which is
called by make_entry and svn_fs__dag_copy.  The svn_fs__dag_copy case
will, however, become a use of svn_fs__new_successor_id.

--

svn_fs__new_successor_id: needs a txn_id and an optional copy id.
node id is inherited.  Careful though:  successor allocation is a bit
tricky due to passive migration of copied subtree items.  That is, if
I copy /dir1 to /dir2, dir2 gets a new copy id, but its children are
generally untouched.  However, the next change made to one of dir2's
children will earn the copy ID granted to dir2.  I suppose that
open_path or make_path_mutable will need to track where it finds a
directory whose copy id is different than that of its children (and
verify that this difference isn't because the children were copied
again or something) and hand the copy ID to DAG functions that will
modify the children.  Actually, now that I think about it,
make_path_mutable is the key here...  Of course, we still have to pass
the stupid txn id into every function that tests mutability of nodes. 
:-(

svn_fs__new_successor_id is called by svn_fs__create_successor and by
merge, but the merge case will go away.  svn_fs__create_successor is
called by svn_fs__dag_clone_root and svn_fs__dag_clone_child, as
expected.

--

"In which revisions did this node change?"  Given a node revision id,
we'd like to know in what revisions this node has changed, and we'd
like the option of filtering out changes that occurred before the last
time this node was copied.

Algorithm looks like this:

   while (NODE-REV-ID):
     get TXN_ID from node revision id.
     lookup REVISION with TXN_ID.
     add REVISION to return value.
     if ((filtering) and (my COPY_ID != my predecessor's COPY_ID))
       break;
     NODE-REV-ID = node revision's predecessor id

--

Hm...consider svn_fs__walk_predecessors (fs, id, func *, baton, trail)
which walks the predecessor list of ID, calling FUNC with BATON before
each traversal.  FUNC can return some custom error to the walker which
can be detected as a non-fatal sentinel (so you only walk back as far
as you need to).  Wonder how useful this would be...?  Could be great
for the revisions_changed question (using some flag in BATON to tell
FUNC to detect when a copy event has been "crossed").  Sleep on this.

--

Hm...looks like we can't remove the stabilization walk until we find a
better time to mark our representations as immutable, or stop using a
mutability flag on those skels.  Major disappointment.

AH!  Of course.  I think the representations need only to store a
TXN_ID (instead of a mutability flag) and simply compare that with the
current transaction ID as a mutability test, just like the node
revisions will.  *That* should eliminate the stabilization walk, since
the minute the txn is committed, all those reps become effectively
immutable.

--

svn_fs__dag_check_mutable still has dumb arguments.  Fix it.

--

Still need to do `copy_id' inheritence walk in open_path or
make_path_mutable or something...

