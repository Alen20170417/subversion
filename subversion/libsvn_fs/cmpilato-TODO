=============================================================================
THOTZ: (by cmpilato, on conversion to the new NodeRevId system)
              *** do not merge me into the main trunk **
=============================================================================

There is a single use of svn_fs_id_distance() in merge that needs
examination.  svn_fs_id_distance is being used as a relatedness check,
but (and this is a general issue in the filesystem code)
svn_fs_id_distance *used* to claim that copied things were unrelated
to their sources, and this is no longer the case.  All users of
svn_fs_id_distance need to be examined to see if this changed concept
of relatedness effects their particular use of svn_fs_id_distance.

--

Deltification is currently the only process in place that asks the
question, "Where is my next successor?"  Currently the question is
answered by doing a little node revision id mathematics; that's no
longer an option.  Input to deltification is still root/path, so what
might a new algorithm be?

This from Bill Tutt:

   This is kind of funky now. A portion of the answer is very similar
   to the problem of "What should my CopyID be for a new NodeRevision
   I need to create now?"
   
   The solution to this general question (as you noticed elsewhere) is
   to acquire it during your path walk.  i.e.: 
   svn_fs_node_id (&(args.id), root, path, pool)
   
   The other funky part is taking this "successor CopyID" calculation
   in combination with the TxnID ordering.
   
      get TXN_ID from node revision id.
      Lookup REVISION with TXN_ID
      I = 1
      Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
      While REVISION+I is valid 
            AND Not Exists NodeID.<calculated
      CopyID>.POSSIBLE_SUCCESSOR_TXN_ID:
         I++
         Lookup the POSSIBLE_SUCCESSOR_TXN_ID for REVISION+I
   
   If you find a NodeRevision that exists, you've found your
   successor, and you should be able to assert that the predecessor is
   the NodeRevision you started from.
   
   Otherwise there is no possible successor.

--

Need to examine the copy_id choosing algorithm in open_path().

--

"In which revisions did this node change?"  Given a node revision id,
we'd like to know in what revisions this node has changed, and we'd
like the option of filtering out changes that occurred before the last
time this node was copied.

Algorithm looks like this:

   while (NODE-REV-ID):
     get TXN_ID from node revision id.
     lookup REVISION with TXN_ID.
     add REVISION to return value.
     if ((filtering) and (my COPY_ID != my predecessor's COPY_ID))
       break;
     NODE-REV-ID = node revision's predecessor id

Let this serve as a reminder to re-implement txn_body_revisions_changed.

--

Consider svn_fs__walk_predecessors (fs, id, func *, baton, trail)
which walks the predecessor list of ID, calling FUNC with BATON before
each traversal.  FUNC can return some custom error to the walker which
can be detected as a non-fatal sentinel (so you only walk back as far
as you need to).  Wonder how useful this would be...?  Could be great
for the revisions_changed question (using some flag in BATON to tell
FUNC to detect when a copy event has been "crossed").  Sleep on this.

--

Hm...looks like we can't remove the stabilization walk until we find a
better time to mark our representations as immutable, or stop using a
mutability flag on those skels.  Major disappointment.

AH!  Of course.  I think the representations need only to store a
TXN_ID (instead of a mutability flag) and simply compare that with the
current transaction ID as a mutability test, just like the node
revisions will.  *That* should eliminate the stabilization walk, since
the minute the txn is committed, all those reps become effectively
immutable.
