The formulative plan for prototyping a Merge Tracking implementation
for Subversion's core <http://subversion.tigris.org/merge-tracking/>.

Phase 1
=======

Record and use merge history to avoid the repeated merge problem and
allow for cherry-picking.  Expose merge info via properties.  Allow
for repos dump/load, including the merge history index.

* Make parameters to the 'svn merge -cN URL' command optional.  This
  should be supported by the API itself (not just in the command-line
  client).

  * Default revision range to "all unmerged revisions" (for -r/-c),
    "oldest revision at merge source's path" thru HEAD.

  * Default merge source to that the any single source in any merge
    info already present on the target of the merge.

* Allow for merge info which contains empty range lists, necessary for
  override of merge info by child paths which would otherwise inherit
  merge info from their parents which they don't reflect.

  * Assure that the code path from client to FS allows such values to
    make it all the way through to the FS and into the merge info
    index in a meaningful fashion yet.

* Assure that 'propdel' sets empty range lists for any inherited merge
  info. (?)

* Make 'propedit' pull down merge info from the repository and combine
  it with any WC-local merge info. (?)

  * Alter code as low-level as svn_fs_node_proplist(), or stay
    higher-level, near svn_client_propget2()?

* Handle notifications resulting from a merge.  (dlr)

  * Handle multiple notifications for single WC items. Possible
    solutions include:

    * Output multiple notifications, but print divider lines
      indicating the revisions range to which a set of notifications
      applies.  Introduce a new type of "skipped" notification for WC
      items which are already in conflict.

    * Collate changes as merge ranges are applied.  Detect and handle
      collisions (multiple notifications to the same WC item), giving
      preference to later notifications (?).

  * Handle skips.

    * If all changes in a merge are skipped, no merge info should be
      recorded for the target.

    * If only some changes are skipped, merge info should be recorded
      for the target, and recorded as empty (or with no modifications,
      if there is pre-existing merge info) for the skipped items.

  * Handle conflicts.

    * If a conflict is encountered, invoke a conflict resolution
      callback to give a Subversion client a chance to intervene.  If
      resolution is successful, convert the notification from a 'C' to
      something else (e.g. 'M').  (Phase 2?)

    * Otherwise, stop applying merge ranges as soon as a second
      conflict is encountered in a WC item (as it might generate
      overlapping conflict makers, or apply a merge inside a conflict
      marker!), being sure to record partial application of merge
      ranges.

* Handle merge info inheritance (and eliding, if any additional work
  is necessary).  (pburba/dlr)

  * Fix inheritance bugs, issues #2733 and #2734.

  * Improve merge algorithm used for target trees with child paths
    that contain differing merge info, per Peter Lundblad's
    suggestions. (?)

  * When a tree with inherited merge info contains a child with
    differing merge info, lookup of the merge info for this child must
    reflect that of the parent (except for where they differ).
    (pburba/dlr)

* Treat all revisions from a 'copy' source as merge info for the
  destination.  This equates to turning all those revs into actual
  merge info (target merge info = source revs + source merge info).

  * Update design spec.  (dberlin?)

  * Handle all 'copy'/'move' operation types.  (dlr)
    http://subversion.tigris.org/merge-tracking/func-spec.html#copy-move

* Handle three-way merges (e.g. 'svn merge URL1 URL2 WC_TARGET').
  We'll likely need to use a different method of calculating the set
  of revision ranges to merge than we do for a straight single repos
  URL -> WC merge.

  We'll need to account for the WC target's mergeinfo, probably when
  calculating the differences between URL1 to URL2, since we won't
  have access to the individual deltas represented by the diff when
  merging the changes into the WC.  If we rev'd the ways deltas came
  down through the editor, we might be able to account for the merge
  info on the client-side instead.

  This is responsible for the failure of merge test #19, which fails
  because the HEAD revision is used for both URLs, which upon
  retrieving the same revnum for each URL appears to the new 'merge'
  logic as neither a merge nor a revert, and is thus considered a
  no-op.

  * As a first cut, punt and restore the code from trunk for 3-way
    merges to keep the complexity of the 'merge' logic from getting
    out of hand.

  * A better solution requires that either the client or server know
    the merge info for both the WC and repos.  This would be
    implemented by transfering the merge info for the versioned
    sub-tree(s) involved in the merge to or from the repository via a
    (new?) RA operation, allowing the calculation of which merges
    remain.  The plan is to do this processing on the server-side, an
    unfortunate difference from the more typical 'merge -rX:Y' style
    of operation (which will be kept client-side to offload more
    processing from the server).

* Update design.html with the latest content from the design spec
  in the notes/ dir.



Phase 2
=======

Implement auditing/reporting and other high-level features.

* Allow most/all arguments to 'merge' to be optional (via a
  combination of using merge info and copy history).  (dberlin)

  * Merge source (a URL) defaults to any single previously used merge
    source.  If there are multiple previous merge sources, a specific
    source must be specified.

  * Revision range defaults to "all available revisions from the merge
    source".

* Add some set of svnmerge.py-like commands for merge info
  auditing/editing to the 'svn' command-line binary.
  
  * Discuss the following command set on the dev list (as just a
    jumping-off point):

    avail         Show unmerged revisions available for PATH as a revision list
      --all         show both available and blocked revisions (aka ignore
                    blocked revisions)
      --diff        show corresponding diff instead of revision list
      --log         show corresponding log history instead of revision list
    block         Block revisions within PATH so that they disappear from the
                  available list
    integrated    Show merged revisions available for PATH as a revision list
      --diff        show corresponding diff instead of revision list
      --log         show corresponding log history instead of revision list
    merge
      --record-only do not perform an actual merge of the changes, yet record
                    that a merge happened  (likely phase 1?)
    unblock       Revert the effect of 'block'

  * Write up outcome in func-spec.html.

* Much more to come...
