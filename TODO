The formulative plan for prototyping a Merge Tracking implementation
for Subversion's core <http://subversion.tigris.org/merge-tracking/>.

Phase 1
=======

Record and use merge history to avoid the repeated merge problem and
allow for cherry-picking.  Expose merge info via properties.  Allow
for repos dump/load, including the merge history index.

* Handle notifications resulting from a merge.  (dlr)

  * Handle multiple notifications for single WC items. Possible
    solutions include:

    * Output multiple notifications, but print divider lines
      indicating the revisions range to which a set of notifications
      applies.  Introduce a new type of "skipped" notification for WC
      items which are already in conflict.

    * Collate changes as merge ranges are applied.  Detect and handle
      collisions (multiple notifications to the same WC item), giving
      preference to later notifications (?).

  * Handle skips.  Merge test 3 fails because a merge of a revision
    range which contains a delete will not delete locally modified
    files (at least, not without --force), but is still recording
    merge info.

    * If all changes in a merge are skipped, no merge info should be
      recorded for the target.

    * If only some changes are skipped, merge info should be recorded
      for the target, and recorded as empty (or with no modifications,
      if there is pre-existing merge info) for the skipped items.

  * Handle conflicts.

    * If a conflict is encountered, invoke a conflict resolution
      callback to give a Subversion client a chance to intervene.  If
      resolution is successful, convert the notification from a 'C' to
      something else (e.g. 'M').  (Phase 2?)

    * Otherwise, stop applying merge ranges as soon as a second
      conflict is encountered in a WC item (as it might generate
      overlapping conflict makers, or apply a merge inside a conflict
      marker!), being sure to record partial application of merge
      ranges.

* Handle merge info inheritance (and eliding, if any additional work
  is necessary).  (madanus)

  * Handle inherited merge info for solely the target.

  * Handle differences in inherited/WC-local merge info for children
    of the target.

* When a tree with inherited merge info contains a child with
  differing merge info, lookup of the merge info for this child must
  reflect that of the parent (except for where they differ).  (dberlin)

* Treat all revisions from a 'copy' source like merge info for the
  destination.  This may equate to turning all those revs into actual
  merge info (target merge info = source revs + source merge info
  ... simpler?), or deriving that info on an as-needed basis.

  * Update design spec.  (dberlin?)

  * Update code.  (madanus)

  * Anything similar necessary for moves?

* Refactor merge info index-related code into a module, and use this
  from libsvn_fs_fs.  (Can we use libsvn_fs as its home, or would that
  introduce a cyclic dependency?)  (kamesh/cmpilato?)

* Handle merge info in the BerkeleyDB FS backend using the modularized
  merge info index API.  (kamesh/cmpilato?)

* Consolidate merge info storage in the index, removing it from the FS. (?)

* Move update design.html with the latest content from the design spec
  in the notes/ dir.

* ra_serf: Implement svn_ra_get_merge_info() (phase 2?).



Phase 2
=======

Implement auditing/reporting and other high-level features.

* Allow most/all arguments to 'merge' to be optional (via a
  combination of using merge info and copy history).  (dberlin)

  * Merge source (a URL) defaults to any single previously used merge
    source.  If there are multiple previous merge sources, a specific
    source must be specified.

  * Revision range defaults to "all available revisions from the merge
    source".

* Add some set of svnmerge.py-like commands for merge info
  auditing/editing to the 'svn' command-line binary.
  
  * Discuss the following command set on the dev list (as just a
    jumping-off point):

    avail         Show unmerged revisions available for PATH as a revision list
      --all         show both available and blocked revisions (aka ignore
                    blocked revisions)
      --diff        show corresponding diff instead of revision list
      --log         show corresponding log history instead of revision list
    block         Block revisions within PATH so that they disappear from the
                  available list
    integrated    Show merged revisions available for PATH as a revision list
      --diff        show corresponding diff instead of revision list
      --log         show corresponding log history instead of revision list
    merge/rollback
      --record-only do not perform an actual merge of the changes, yet record
                    that a merge happened  (likely phase 1?)
    unblock       Revert the effect of 'block'

  * Write up outcome in func-spec.html.

* Much more to come...
