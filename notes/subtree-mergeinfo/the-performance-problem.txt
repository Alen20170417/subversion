THE PERFORMANCE HIT
-------------------

Looking at use case B, we have a serious performance problem that can get
worse over time if we don't set mergeinfo on subtrees untouched by a merge.

Start with this simple repository at revision 1:

trunk/
trunk/code/
trunk/code/README
trunk/code/inc/
trunk/code/inc/subr.h
trunk/code/src/
trunk/code/src/client/
trunk/code/src/client/main.c
trunk/code/src/client/cmd.c
trunk/code/src/server/
trunk/code/src/server/main.c
trunk/code/src/server/serve.c
trunk/code/src/subr/
trunk/code/src/subr/subr.c
branches

In r2 we copy trunk to branches/b1.0

In r3-r15 we make various changes under trunk.

Now we start merging (assume a commit and update after each of these merges)
in such a way as to create subtree mergeinfo (in this example we do it the
simple way, with subtree merges, but it's largely irrelevant *how* the
subtree mergeinfo comes into being):


===== r16 =====

  >svn merge %url%/trunk/code/src branches\b1.0\code\src -c5
  --- Merging r5 into 'branches\b1.0\code\src':
  U    branches\b1.0\code\src\server\main.c
  U    branches\b1.0\code\src\server\serve.c
  U    branches\b1.0\code\src\subr\subr.c
  U    branches\b1.0\code\src\client\cmd.c
  U    branches\b1.0\code\src\client\main.c

  TPH>svn pg svn:mergeinfo -vR
  Properties on 'branches\b1.0\code\src':
    svn:mergeinfo
      /trunk/code/src:5

Nothing unusual or different from our current trunk behavior here.


===== r17 =====

  TPH>svn merge %url%/trunk/code/README  branches\b1.0\code\README -c3
  --- Merging r3 into 'branches\b1.0\code\README':
  U    branches\b1.0\code\README

  TPH>svn pg svn:mergeinfo -vR
  Properties on 'branches\b1.0\code\src':
    svn:mergeinfo
      /trunk/code/src:5
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:3

Again, nothing different from trunk here either.


===== r18 =====

  TPH>svn merge %url%/trunk branches\b1.0 -c10
  --- Merging r10 into 'branches\b1.0\code\src':
  A    branches\b1.0\code\src\client\cmd2.c

  TPH>svn pg svn:mergeinfo -vR
  Properties on 'branches\b1.0':
    svn:mergeinfo
      /trunk:10
  Properties on 'branches\b1.0\code\src':
    svn:mergeinfo
      /trunk/code/src:5,10
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:3

  TPH>svn st
   M      branches\b1.0
   M      branches\b1.0\code\src
  A  +    branches\b1.0\code\src\client\cmd2.c

Here is some new behavior, 'branches\b1.0\code\README' was untouched by 
the merge, so its mergeinfo remains unmodified.  No problem yet.


===== r19 =====

Now let's merge every available revision directly to
'branches\b1.0\code\src\client\main.c', but instead of not specifying a
revision range we use the mergeinfo subcommand to find the operative
revisions and specify those (the only difference is in the recorded
mergeinfo describing the merge):

  TPH>svn mergeinfo %url%/trunk/code/src/client/main.c
  branches\b1.0\code\src\client\main.c --show-revs eligible
  r9
  r12
  r13
  r14

  TPH>svn merge %url%/trunk/code/src/client/main.c
  branches\b1.0\code\src\client\main.c -c9,12,13,14
  --- Merging r9 into 'branches\b1.0\code\src\client\main.c':
  U    branches\b1.0\code\src\client\main.c
  --- Merging r12 into 'branches\b1.0\code\src\client\main.c':
  G    branches\b1.0\code\src\client\main.c
  --- Merging r13 into 'branches\b1.0\code\src\client\main.c':
  G    branches\b1.0\code\src\client\main.c
  --- Merging r14 into 'branches\b1.0\code\src\client\main.c':
  G    branches\b1.0\code\src\client\main.c

  TPH>svn st
  MM      branches\b1.0\code\src\client\main.c

  TPH>svn pg svn:mergeinfo -vR
  Properties on 'branches\b1.0':
    svn:mergeinfo
      /trunk:10
  Properties on 'branches\b1.0\code\src':
    svn:mergeinfo
      /trunk/code/src:5,10
  Properties on 'branches\b1.0\code\src\client\main.c':
    svn:mergeinfo
      /trunk/code/src/client/main.c:5,9-10,12-14
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:3

===== r20 =====
ELISION BREAKS
===============

Now we merge every available revision to 'branches\b1.0\code\src\client',
this time the more "traditional" way by not specifying a revision range:

  TPH>svn merge %url%/trunk/code/src/client branches\b1.0\code\src\client
  --- Merging r6 through r8 into 'branches\b1.0\code\src\client':
  U    branches\b1.0\code\src\client\cmd.c
  --- Merging r9 into 'branches\b1.0\code\src\client':
  G    branches\b1.0\code\src\client\cmd.c
  --- Merging r11 into 'branches\b1.0\code\src\client':
  U    branches\b1.0\code\src\client\cmd2.c
  --- Merging r12 through r19 into 'branches\b1.0\code\src\client':
  G    branches\b1.0\code\src\client\cmd.c
  G    branches\b1.0\code\src\client\cmd2.c

  TPH>svn st
   M      branches\b1.0\code\src\client
  M       branches\b1.0\code\src\client\cmd.c
  M       branches\b1.0\code\src\client\cmd2.c

  TPH>svn pl -vR
  Properties on 'branches\b1.0':
    svn:mergeinfo
      /trunk:10
  Properties on 'branches\b1.0\code\src':
    svn:mergeinfo
     /trunk/code/src:5,10
  Properties on 'branches\b1.0\code\src\client':
    svn:mergeinfo
      /trunk/code/src/client:2-19
  Properties on 'branches\b1.0\code\src\client\main.c':
    svn:mergeinfo
      /trunk/code/src/client/main.c:5,9-10,12-14
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:3

Again we see the new behavior, the two subtrees under
'branches\b1.0\code\src\client' with explicit mergeinfo,
'branches\b1.0\code\src\client\main.c' and 'branches\b1.0\code\README',
are untouched by the merge so don't have their mergeinfo updated.
Previously the mergeinfo on both would have been updated to:

  Properties on 'branches\b1.0\code\src\client\main.c':
    svn:mergeinfo
      /trunk/code/src/client/main.c:2-19
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:2-19

This would of course have elided to 'branches\b1.0\code\src\client' at the
end of the merge, leaving mergeinfo only on 'branches\b1.0\code\src\client'.
But since the subtree mergeinfo is never set, elision as it works today
does not happen.

===== r21 =====
THE PROBLEM
===============

Now we decide to merge all available revisions to 'branches\b1.0\code':

  TPH>svn merge %url%/trunk/code branches\b1.0\code
  --- Merging r3 through r4 into 'branches\b1.0\code\src':
  U    branches\b1.0\code\src\subr\subr.c
  --- Merging r3 through r4 into 'branches\b1.0\code':
  U    branches\b1.0\code\inc\subr.h
  --- Merging r6 through r8 into 'branches\b1.0\code\src':
  U    branches\b1.0\code\src\server\serve.c
  G    branches\b1.0\code\src\subr\subr.c
  --- Merging r12 through r20 into 'branches\b1.0\code\src':
  U    branches\b1.0\code\src\server\main.c
  G    branches\b1.0\code\src\server\serve.c
  G    branches\b1.0\code\src\subr\subr.c

None of the incoming changes are to 'branches\b1.0\code\src\client\main.c'
or 'branches\b1.0\code\README' so the mergeinfo on those subtrees of the
target remains untouched:

  TPH>svn st
   M      branches\b1.0\code
   M      branches\b1.0\code\src
  M       branches\b1.0\code\src\server\main.c
  M       branches\b1.0\code\src\server\serve.c
  M       branches\b1.0\code\src\subr\subr.c
  M       branches\b1.0\code\inc\subr.h

  TPH>svn pl -vR
  Properties on 'branches\b1.0':
    svn:mergeinfo
      /trunk:10
  Properties on 'branches\b1.0\code':
    svn:mergeinfo
      /trunk/code:2-20
  Properties on 'branches\b1.0\code\src\client':
    svn:mergeinfo
      /trunk/code/src/client:2-19
  Properties on 'branches\b1.0\code\src\client\main.c':
    svn:mergeinfo
      /trunk/code/src/client/main.c:5,9-10,12-14
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:3

Now for the performance hit. We commit this merge then try to repeat it
(we'll sepcify -r1:20 so as not to dela with HEAD now being r21):

  TPH>svn merge %url%/trunk/code branches\b1.0\code -r1:20

  TPH>svn st

  TPH>

A noop, that's expected, so what?  The problem is that based on the
mergeinfo it *appears* that r1:20 is *not* fully merged to the tree rooted
at 'branches\b1.0\code'.  Specifically it looks like the following subtrees
are missing these revisions from trunk:

  'branches\b1.0\code\src\client':        r20 
  'branches\b1.0\code\src\client\main.c': r2-4, r6-8, r11, r15-20
  'branches\b1.0\code\README':            r2, r4-20

It doesn't matter that all of these revisions are noops on the paths in
question on trunk -- the diff editor still gets driven because of this.
If we drop this following code snippet at the start of libsvn_client/merge.c:
drive_merge_report_editor() and rerun the merge we see that this is
happening.

[[[
  printf("\n==========================================================\n");
  printf("===== DRIVE EDITOR\n");
  printf("===== %s@%d:\n", url1, revision1);
  printf("===== %s@%d\n", url2, revision2);
  printf("==========================================================\n\n");
]]]

TPH>svn merge %url%/trunk/code branches\b1.0\code -r1:20

  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@1:
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@2
  ==========================================================


  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@2:
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@4
  ==========================================================


  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@4:
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@8
  ==========================================================


  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@8:
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@11
  ==========================================================


  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@11:
  ===== http://localhost/svn-test-work/repositories/TPH/trunk/code@20
  ==========================================================

  TPH>
  
  Note: How the editor drives get cut up is described in
        drive_merge_report_editor's doc string and comments.
  
Five editor drives with their requisite network round trips for a noop
merge!  If we had been setting mergeinfo on all subtrees regardless of
whether they were touched by the merge there would be *NO* noop editor
drives.  You can see this if you manually set the mergeinfo on the three
subtrees to reflect the fact that all of r2-20 has been merged from trunk
(and yes if an actual merge had performed resulted in this then elision
would have consolidated all the mergeinfo on 'branches\b1.0\code' but that
doesn't impact this example either way):

  TPH>svn ps svn:mergeinfo "/trunk/code/src/client:2-20"
      branches\b1.0\code\src\client
  property 'svn:mergeinfo' set on 'branches\b1.0\code\src\client'

  TPH>svn ps svn:mergeinfo "/trunk/code/src/client/main.c:2-20"
      branches\b1.0\code\src\client\main.c
  property 'svn:mergeinfo' set on 'branches\b1.0\code\src\client\main.c'

  TPH>svn ps svn:mergeinfo "/trunk/code/README:2-20"
      branches\b1.0\code\README
  property 'svn:mergeinfo' set on 'branches\b1.0\code\README'

  TPH>svn pl -vR
  Properties on 'branches\b1.0':
    svn:mergeinfo
      /trunk:10
  Properties on 'branches\b1.0\code':
    svn:mergeinfo
      /trunk/code:2-20
  Properties on 'branches\b1.0\code\src\client':
    svn:mergeinfo
      /trunk/code/src/client:2-20
  Properties on 'branches\b1.0\code\src\client\main.c':
    svn:mergeinfo
      /trunk/code/src/client/main.c:2-20
  Properties on 'branches\b1.0\code\README':
    svn:mergeinfo
      /trunk/code/README:2-20

  TPH>svn merge %url%/trunk/code branches\b1.0\code -r1:20

  TPH>
 
The overhead of these editor drives never go away unless we manipulate
the subtree mergeinfo like the previous example.

SO HOW BAD CAN IT GET?
----------------------

In example above the network roundtrips incurred are not that serious.
But what happens if a branch has hundreds or thousands of subtrees with
mergeinfo?  It happens: 
subversion.open.collab.net/ds/viewMessage.do?dsForumId=4&dsMessageId=310927

To get a feel of how bad performance can get I used a mirror of Subversion's
trunk and made branch 'stmi-test' copied from trunk@36000.  Then I set
empty mergeinfo on *every* subtree (1731 paths total) in that branch.

Wait, you are probably wondering why, who would set empty mergeinfo on
every subtree?  Nobody, but here we only want to create *some* kind of
starting explicit subtree mergeinfo.  In the "real world" it might have
come from subtree merges, shallow merges, Wc-to-WC copies made before we
stopped recording mergeinfo on the desitination, etc., but the point is
that a newly created branch can have subtree mergeinfo.

Then, in r36965-r37464, I merged r36001-r36500 from trunk to the branch one
revision at a time using a build of this branch (i.e.
branches/subtree-mergeinfo) so subtree mergeinfo is not updated if the merge
doesn't touch the subtree.

Effectively this simulates the worst-case of use case B.1 'FEATURE BRANCHES'
as this is the ultimate example of ongoing sync merges (i.e. a sync merge
for each individual rev).  It also simulates the worst case use case
B.2 'RELEASE BRANCHES' (i.e. every revision from trunk between r36001 and
r36500 was individually backported).  The mergeinfo resulting from this can
be found at notes/subtree-mergeinfo/full-mergeinfo-list-use-case-B1.txt.

Let's look at B.2 'RELEASE BRANCHES' first because things aren't quite as
bad as B.1 and some good (less bad?) news is needed in this discussion.

Use Case B.2 'Release Branches' and the Implicit Mergeinfo Query Problem
------------------------------------------------------------------------

As a release branch we'll likely be cherry picking small numbers of
individual revisions for backport, let's keep things simple and assume a
single revision to the root of the branch:

  C:\SVN\stmi-test-stmibranch>svn merge ^^trunk -c36501
  
  ==========================================================
  ===== DRIVE EDITOR
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36500:
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36501
  ==========================================================

  --- Merging r36501 into 'subversion\libsvn_wc\wc_db.c':

Only one editor drive, that's expected because we haven't yet merged r36501
so every subtree with mergeinfo "needs" this revision.  When every subtree
with mergeinfo needs the same revision (or rev range) then only one editor
drive is needed.  The problem here is in the work to figure out *if* each
subtree needs r36501 or not (see
libsvn_client/merge.c:calculate_remaining_ranges() and
filter_merged_revisions()).  There are two ways to determine this.  The
quick and easy way is to look at the mergeinfo on the subtree, is r36501
from trunk represented?  If so then we know this subtree doesn't need
r36501.  But if r36501 is not represented in the mergeinfo then we must
know the subtree's implicit mergeinfo (a.k.a. natural history) and to do
this filter_merged_revisions() ultimately calls
svn_ra_get_location_segments() resulting in a roundtrip to the server:

  filter_merged_revisions()
  get_full_mergeinfo()
  svn_client__get_history_as_mergeinfo()
  svn_client__repos_location_segments()
  svn_ra_get_location_segments()

Note that this call to svn_ra_get_location_segments() is going to happen
for *EVERY* subtree with mergeinfo, in this case 1731 times!

Recently on trunk (r36509) did we make a change to limit these checks for
implicit mergeinfo to the cases where the answer wasn't already provided
by the explicit mergeinfo.  But this change doesn't help us here because
we've never merged r36501.  In fact, for this use case this "Implicit
Mergeinfo Query Problem" is neither better nor worse if we don't record
mergeinfo on untouched subtrees.  So it would appear that we have nothing
to lose in not recording inoperative subtree mergeinfo.  The only minor(?)
concern is that, depending on the disposition of elision, we might end up
with more subtrees with mergeinfo than we would have otherwise, making
this problem worse.

Use Case B.1 'Feature Branches' and the Inoperative Editor Drive Problem
------------------------------------------------------------------------

Not recording inoperative subtree mergeinfo really hurts performance when
dealing with feature branches.  We'll start with the same branch(@37464)
as at the start of the B.2 example above.  This time though we'll treat it
like a feature branch and follow the branch changes, sync merge, reintegrate
model.

First we merge all available revisions from trunk (a sync merge).  Normally
we do this by not specifying any explicit revision ranges, which implies a
revision range of -r0:HEAD.  Here, to keep things comparable to the B.2
example we'll act as if HEAD is r36501 by using an explicit range:

  stmi>svn merge ^^/trunk . -r0:36501

  ==========================================================
  ===== DRIVE EDITOR 1
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36000:
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36007
  ==========================================================

  ==========================================================
  ===== DRIVE EDITOR 2
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36007:
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36008
  ==========================================================

  .
  .
  .
  <Snipped 318 inoperative editor drive notifications>
  .
  .
  .
  
  ==========================================================
  ===== DRIVE EDITOR 321
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36497:
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36498
  ==========================================================

  ==========================================================
  ===== DRIVE EDITOR 322
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36498:
  ===== http://localhost/svn-test-work/repositories/svn-MIRROR/trunk@36501
  ==========================================================

  --- Merging r36499 through r36501 into 'subversion\libsvn_wc\wc_db.c':
  U    subversion\libsvn_wc\wc_db.c

  stmi>svn st
   M      .
   M      subversion
   M      subversion\libsvn_wc
  MM      subversion\libsvn_wc\wc_db.c

Ouch!  First it should be noted that the 1731 calls to
svn_ra_get_location_segments() that happened in the B.2 example happen here
too for that same reasons, so the 'Implicit Mergeinfo Query Problem' is alive
and well.  On top of that there are 321 inoperative editor drives.  This is
because, while r36001-36500 *has* been merged from trunk, the subtree
mergeinfo on the branch does not explicitly reflect this.  We can see this if
we look at the mergeinfo on a subtree prior to the merge (Note that only the
operative merges done while merging r36001-36500, one revision at a time,
were recorded here):

  stmi>svn pg svn:mergeinfo -v subversion\libsvn_client
  Properties on 'subversion\libsvn_client':
    svn:mergeinfo
      /trunk/subversion/libsvn_client:36049-36051,36103-36104,36106,36131,
      36158,36170,36229,36236,36253,36256,36265,36269,36272,36279-36280,
      36296-36297,36404,36420,36424-36426,36444,36459,36477

Based on the explicit mergeinfo and natural history of
subversion\libsvn_client it still appears that r36001-36048, r36052-36102,
r36105, r36107-36130, r36132-36157, r36159-36169, r36171-36228, r36230-36235,
r36237-36252, r36254-36255, r36257-36264, r36266-36268, r36270-36271,
r36273-36278, r36281-36295, r36298-36403, r36405-36419, r36421-36423,
r36427-36443, r36445-36458, r36460-36476, and r36478-36500 (whew!) all need
to be merged from trunk/subversion/libsvn_client -- hence the hundreds of
inoperative editor drives as the merge code tries to do just that.

The merge can't differentiate this situation from one where subtree merges
where done, e.g. maybe r36105 was operative but was reverse merged during a
subtree merge to libsvn_client and a sync merge of this revision *would* be
operative within the libsvn_client subtree.  Unfortunately, if we don't
blindly update all the subtree mergeinfo to describe the sync merge then
these inoperative editor drives happen every time.  In other words, because
we are *never* going to set, say '/trunk/subversion/libsvn_client:36001-36048'
on subversion/libsvn_client, because those revisions are inoperative on
trunk/subversion/libsvn_client, the merge code will always consider those
revisions eligible and try to merge them.  End result: Performance sapping
inoperative editor drives.
